import { EventEmitter } from 'events';
import { Coords3, GeneratorType, Generator, Coords2 } from '../libs';
import { Chunk } from './chunk';
import { Engine } from './engine';
declare type WorldOptionsType = {
    maxHeight: number;
    chunkSize: number;
    chunkPadding: number;
    dimension: number;
    generator?: GeneratorType;
    renderRadius: number;
    maxChunkPerFrame: number;
    maxBlockPerFrame: number;
};
declare class World extends EventEmitter {
    engine: Engine;
    generator: Generator;
    options: WorldOptionsType;
    isReady: boolean;
    private camChunkName;
    private camChunkPos;
    private chunks;
    private dirtyChunks;
    private visibleChunks;
    private batchedChanges;
    constructor(engine: Engine, options: WorldOptionsType);
    tick(): void;
    getChunkByCPos(cCoords: Coords2): Chunk | null;
    getChunkByName(chunkName: string): Chunk | null;
    getChunkByVoxel(vCoords: Coords3): Chunk | null;
    getNeighborChunksByVoxel(vCoords: Coords3, padding?: number): (Chunk | null)[];
    getVoxelByVoxel(vCoords: Coords3): number | null | undefined;
    getVoxelByWorld(wCoords: Coords3): number | null | undefined;
    getMaxHeightByVoxel(vCoords: Coords3): number;
    getSolidityByVoxel(vCoords: Coords3): boolean;
    getFluidityByVoxel(vCoords: Coords3): boolean;
    getSolidityByWorld(wCoords: Coords3): boolean;
    getFluidityByWorld(wCoords: Coords3): boolean;
    setChunk(chunk: Chunk): number | undefined;
    setVoxel(vCoords: Coords3, type: number): void;
    breakVoxel(): void;
    placeVoxel(type: number): void;
    addAsVisible(chunk: Chunk): void;
    removeAsVisible(chunk: Chunk): void;
    get camChunkPosStr(): string;
    private checkCamChunk;
    private surroundCamChunks;
    private meshDirtyChunks;
    private requestChunkData;
}
export { World, WorldOptionsType };
